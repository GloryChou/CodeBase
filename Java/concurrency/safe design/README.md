# 保障线程安全的设计技术

### 无状态对象
**对象**就是操作和数据的封装。对象所包含的数据就被称为该对象的**状态**，它包括存储在实例变量或者静态变量之中的数据。相应地，实例变量、静态变量也被称为**状态变量**。

如果一个类的同一个实例被多个线程共享并不会使得这些线程存在共享状态，那么这个类及其任意一个实例就被称为**无状态对象**。

反之，如果一个类的同一个实例被多个线程共享，会使这些线程存在共享状态，那么这个类及其任意一个实例就被称为**有状态对象**。

所谓的**无状态对象**就是这样一种办法：一个线程执行无状态对象的任意一个方法来完成某个计算的时候，该计算的瞬时状态（中间结果）仅体现在局部变量或只有当前执行的线程能够访问的对象的状态上。

因此，一个线程执行无状态对象的任何方法都不会对访问该无状态对象的其他线程产生任何干扰作用。这些线程在执行该对象的任何方法的时候都无须使用同步机制。


### 不可变对象
**对象**就是操作和数据的封装。对象所包含的数据就被称为该对象的**状态**，它包括存储在实例变量或者静态变量之中的数据。相应地，实例变量、静态变量也被称为**状态变量**。

如果一个类的同一个实例被多个线程共享并不会使得这些线程存在共享状态，那么这个类及其任意一个实例就被称为**无状态对象**。

反之，如果一个类的同一个实例被多个线程共享，会使这些线程存在共享状态，那么这个类及其任意一个实例就被称为**有状态对象**。

所谓的**无状态对象**就是这样一种办法：一个线程执行无状态对象的任意一个方法来完成某个计算的时候，该计算的瞬时状态（中间结果）仅体现在局部变量或只有当前执行的线程能够访问的对象的状态上。

因此，一个线程执行无状态对象的任何方法都不会对访问该无状态对象的其他线程产生任何干扰作用。这些线程在执行该对象的任何方法的时候都无须使用同步机制。



### 线程持有对象
对于一个非线程安全对象，每个线程都创建一个该对象的实例，各个线程仅访问各自创建的实例，且一个线程不能访问另外一个线程创建的对象实例。这种对象我们称之为：**线程特有对象（Thread Specific Object，TSO）**，相应的线程就被称为该线程特有对象的**持有线程**。

**ThreadLocal&lt;T&gt;**类相当于线程访问其线程特有对象的代理（Proxy），即各个线程通过这个对象可以创建并访问各自的线程特有对象，其类型参数T指定了相应线程特有对象的类型。

> **线程特有对象可能导致的问题及其规避：**
> + 退化与数据错乱：



### 装饰器模式




### 并发集合

